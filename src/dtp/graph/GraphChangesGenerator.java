package dtp.graph;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.JFileChooser;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import measure.MeasureHelper;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import dtp.commission.TxtFileReader;
import dtp.gui.ExtensionFilter;
import dtp.optimization.Dijkstra;
import dtp.optimization.TrackFinder;
import dtp.xml.GraphParser;

public class GraphChangesGenerator {

	private final Graph graph;
	private final TrackFinder finder;
	private final int deadline;

	/**
	 * Number of vehicles, which travel across graph and generate latencies
	 */
	private final int vehicleNr;

	/**
	 * Specifies min and max speed of vehicles - it has influence on how much
	 * latency is generated by each vehicle
	 */
	private final int minSpeed;
	private final int maxSpeed;

	/**
	 * Specifies how frequent, file with graph changes should be updated
	 */
	private final int updateFreq;

	private Document dom;

	public GraphChangesGenerator(Graph graph, String commissionsFile,
			int vehicleNr, int minSpeed, int maxSpeed, int updateFreq,
			TrackFinder finder) throws Exception {
		this.finder = finder;
		this.vehicleNr = vehicleNr;
		this.minSpeed = minSpeed;
		this.maxSpeed = maxSpeed;
		this.updateFreq = updateFreq;
		this.graph = graph;
		this.finder.setGraph(this.graph);
		this.deadline = TxtFileReader.getDeadline(commissionsFile);
	}

	public void generate(String fileName) throws Exception {
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

		DocumentBuilder db = dbf.newDocumentBuilder();
		dom = db.newDocument();
		dom.setXmlVersion("1.0");
		Element graphChangesEl = dom.createElement("graphChanges");
		graphChangesEl.setAttribute("xmlns:xsi",
				"http://www.w3.org/2001/XMLSchema-instance");
		graphChangesEl.setAttribute("xsi:noNamespaceSchemaLocation",
				"xml/schemes/graphChanges.xsd");

		generate(graphChangesEl);
		dom.appendChild(graphChangesEl);
		Source source = new DOMSource(dom);

		File file = new File(fileName);
		Result result = new StreamResult(file);

		Transformer xformer = TransformerFactory.newInstance().newTransformer();
		xformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
		xformer.setOutputProperty(OutputKeys.INDENT, "yes");
		xformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount",
				"4");

		xformer.transform(source, result);

	}

	private class Vehicle {
		public int speed;
		public GraphTrack track;
		public int startTimestamp;
		public int departureTime = 0;
		public int linkNr = 0;
		public int originalLinkTime;
	}

	private List<Vehicle> vehicles;
	private final Map<GraphLink, Integer> vehiclesOnLink = new HashMap<GraphLink, Integer>();

	private void initVechicles() {
		vehicles = new LinkedList<GraphChangesGenerator.Vehicle>();
		Random rand = new Random(Calendar.getInstance().getTimeInMillis());
		Vehicle vehicle;
		GraphPoint startPoint;
		GraphPoint endPoint;
		GraphLink link;
		for (int i = 0; i < this.vehicleNr; i++) {
			vehicle = new Vehicle();
			while ((vehicle.speed = rand.nextInt(maxSpeed + 1)) < minSpeed) {
				// do nothing
			}
			vehicle.startTimestamp = rand.nextInt(deadline);
			startPoint = graph.getPoint(rand.nextInt(graph.getPointsSize()));
			while ((endPoint = graph.getPoint(rand.nextInt(graph
					.getPointsSize()))).equals(startPoint)) {
				// do nothing
			}
			vehicle.track = finder.findTrack(startPoint, endPoint);

			link = vehicle.track.getLink(0);
			Integer count = vehiclesOnLink.get(link);
			if (count == null)
				count = 0;
			count++;
			vehiclesOnLink.put(link, count);
			vehicle.originalLinkTime = (int) link.getCost();
			if (link.getCost() < vehicle.originalLinkTime + vehicle.speed) {
				link.setCost(vehicle.originalLinkTime + vehicle.speed);
			}
			vehicles.add(vehicle);
		}
	}

	private Set<GraphLink> changedLinks = new TreeSet<GraphLink>();
	private final Set<GraphLink> previousLinks = new TreeSet<GraphLink>();

	private void moveVehicles(int timestamp) {
		GraphLink link;
		for (Vehicle vehicle : vehicles) {
			if (vehicle.track.size() - 1 <= vehicle.linkNr)
				continue;
			if (timestamp < vehicle.startTimestamp)
				continue;
			link = vehicle.track.getLink(vehicle.linkNr);
			if (timestamp > vehicle.departureTime + link.getCost()) {
				Integer count = vehiclesOnLink.get(link);
				count--;
				vehiclesOnLink.put(link, count);
				if (count == 0) {
					link.setCost(vehicle.originalLinkTime);
					changedLinks.add(link);
				}

				vehicle.linkNr++;
				if (vehicle.track.size() - 1 <= vehicle.linkNr)
					continue;
				link = vehicle.track.getLink(vehicle.linkNr);

				Integer count2 = vehiclesOnLink.get(link);
				if (count2 == null)
					count2 = 0;
				count2++;
				vehiclesOnLink.put(link, count2);
				vehicle.originalLinkTime = (int) link.getCost();
				if (changedLinks.contains(link))
					changedLinks.remove(link);
				if (link.getCost() < vehicle.originalLinkTime + vehicle.speed) {
					link.setCost(vehicle.originalLinkTime + vehicle.speed);
				}
				vehicle.departureTime = timestamp;
			} else {
				if (link.getCost() < vehicle.originalLinkTime + vehicle.speed) {
					link.setCost(vehicle.originalLinkTime + vehicle.speed);
				}
			}
		}
	}

	private void generate(Element root) {
		Element changeEl;
		initVechicles();

		for (int i = 1; i < deadline; i++) {
			moveVehicles(i);
			if (i % updateFreq == 0) {
				changeEl = dom.createElement("change");
				changeEl.setAttribute("time", new Integer(i).toString());
				boolean sthChanged = false;
				for (GraphLink link : vehiclesOnLink.keySet()) {
					if (vehiclesOnLink.get(link) > 0) {
						if (!previousLinks.contains(link)) {
							changeLinkEl(changeEl, link);
							sthChanged = true;
							previousLinks.add(link);
						}
					}
				}
				for (GraphLink link : changedLinks) {
					changeLinkEl(changeEl, link);
					sthChanged = true;
				}
				changedLinks = new TreeSet<GraphLink>();
				if (sthChanged)
					root.appendChild(changeEl);
			}
		}
	}

	private void changeLinkEl(Element changeEl, GraphLink link) {
		Element changeLinkEl = dom.createElement("link");
		changeLinkEl.setAttribute("sPoint", link.getStartPoint().getId()
				.toString());
		changeLinkEl.setAttribute("ePoint", link.getEndPoint().getId()
				.toString());
		changeLinkEl.setAttribute("cost",
				new Integer((int) link.getCost()).toString());
		changeLinkEl.setAttribute("both", "false");
		changeEl.appendChild(changeLinkEl);

	}

	private static String getFile(String title, String ext) {
		JFileChooser chooser = new JFileChooser(".");
		chooser.setDialogTitle(title);
		chooser.setFileFilter(new ExtensionFilter(new String[] { ext }));
		if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {
			return chooser.getSelectedFile().getAbsolutePath();
		}
		return null;
	}

	public static void main(String args[]) {
		try {

			BufferedReader reader = new BufferedReader(new InputStreamReader(
					System.in));
			System.out.println("Podaj parametry generatora:");
			System.out.print("1. Wybierz plik z opisem grafu: ");
			String graphFile = getFile("Choose graph file", "xml");
			if (graphFile == null) {
				System.out.println("\n");
				System.out.println("Generacja przerwana przez uzytkownika");
				return;
			}
			System.out.println(graphFile);
			System.out
					.print("2. Wybierz plik z opisem zlecen, dla ktorego zostal wygenerowany graf: ");
			String comsFile = getFile("Choose commissions file", "txt");
			if (comsFile == null) {
				System.out.println("\n");
				System.out.println("Generacja przerwana przez uzytkownika");
				return;
			}
			System.out.println(comsFile);
			System.out.print("3. Podaj ilosc wirtualnych pojazdow: ");
			int vehiclesNr = Integer.parseInt(reader.readLine());
			Graph graph = new GraphParser().parse(graphFile);

			Iterator<GraphLink> it = graph.getLinksIterator();
			List<Double> values = new LinkedList<Double>();
			while (it.hasNext()) {
				values.add(it.next().getCost());
			}

			System.out.println("Sredni czas przejazdu w grafie: "
					+ MeasureHelper.average(values));
			System.out
					.println("Odchylenie standardowe czasu przejazdu w grafie: "
							+ MeasureHelper.standardDeviation(values));

			System.out
					.print("4. Podaj minimalny wzrost czasu przejazdu (o ile jednostek): ");
			int minSpeed = Integer.parseInt(reader.readLine());
			System.out
					.print("5. Podaj maksymalny wzrost czasu przejazdu (o ile jednostek): ");
			int maxSpeed = Integer.parseInt(reader.readLine());
			System.out.print("6. Co ile timestampow zapisywac zmiany grafu: ");
			int updateFreq = Integer.parseInt(reader.readLine());
			System.out.print("7. Wybierz gdzie zapisac wynik: ");
			JFileChooser chooser = new JFileChooser(".");
			chooser.setDialogTitle("Save changes file");
			chooser.setFileFilter(new ExtensionFilter(new String[] { "xml" }));
			chooser.setSelectedFile(new File("changes.xml"));
			String changesFile = null;
			if (chooser.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {
				changesFile = chooser.getSelectedFile().getAbsolutePath();
				if (!changesFile.endsWith(".xml")) {
					changesFile += ".xml";
				}
			}
			if (changesFile == null) {
				System.out.println("\n");
				System.out.println("Generacja przerwana przez uzytkownika");
				return;
			}
			System.out.println(changesFile);
			System.out.println("\nGeneracja rozpoczeta");
			if (minSpeed > maxSpeed) {
				int tmp = minSpeed;
				minSpeed = maxSpeed;
				maxSpeed = tmp;
			}
			new GraphChangesGenerator(graph, comsFile, vehiclesNr, minSpeed,
					maxSpeed, updateFreq, new Dijkstra(null))
					.generate(changesFile);
			System.out.println("Generacja zakonczona");
		} catch (NumberFormatException e) {
			System.out.println("\nWprowadzono niepoprawny format liczbowy");
			System.out
					.println("Generacja przerwana z powodu wyst¹pienia bledu");
		} catch (Exception e) {
			System.out.println("Wystapil blad:");
			e.printStackTrace();
		}
	}
}
